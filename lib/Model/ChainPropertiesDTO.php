<?php
/**
 * ChainPropertiesDTO
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  SymbolRestClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Catapult REST Endpoints
 *
 * OpenAPI Specification of catapult-rest
 *
 * The version of the OpenAPI document: 1.0.4
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.2.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SymbolRestClient\Model;

use \ArrayAccess;
use \SymbolRestClient\ObjectSerializer;

/**
 * ChainPropertiesDTO Class Doc Comment
 *
 * @category Class
 * @description Chain related configuration properties.
 * @package  SymbolRestClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ChainPropertiesDTO implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'ChainPropertiesDTO';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'enable_verifiable_state' => 'bool',
        'enable_verifiable_receipts' => 'bool',
        'currency_mosaic_id' => 'string',
        'harvesting_mosaic_id' => 'string',
        'block_generation_target_time' => 'string',
        'block_time_smoothing_factor' => 'string',
        'block_finalization_interval' => 'string',
        'importance_grouping' => 'string',
        'importance_activity_percentage' => 'string',
        'max_rollback_blocks' => 'string',
        'max_difficulty_blocks' => 'string',
        'default_dynamic_fee_multiplier' => 'string',
        'max_transaction_lifetime' => 'string',
        'max_block_future_time' => 'string',
        'initial_currency_atomic_units' => 'string',
        'max_mosaic_atomic_units' => 'string',
        'total_chain_importance' => 'string',
        'min_harvester_balance' => 'string',
        'max_harvester_balance' => 'string',
        'min_voter_balance' => 'string',
        'max_voting_keys_per_account' => 'string',
        'min_voting_key_lifetime' => 'string',
        'max_voting_key_lifetime' => 'string',
        'harvest_beneficiary_percentage' => 'string',
        'harvest_network_percentage' => 'string',
        'harvest_network_fee_sink_address' => 'string',
        'block_prune_interval' => 'string',
        'max_transactions_per_block' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'enable_verifiable_state' => null,
        'enable_verifiable_receipts' => null,
        'currency_mosaic_id' => null,
        'harvesting_mosaic_id' => null,
        'block_generation_target_time' => null,
        'block_time_smoothing_factor' => null,
        'block_finalization_interval' => null,
        'importance_grouping' => null,
        'importance_activity_percentage' => null,
        'max_rollback_blocks' => null,
        'max_difficulty_blocks' => null,
        'default_dynamic_fee_multiplier' => null,
        'max_transaction_lifetime' => null,
        'max_block_future_time' => null,
        'initial_currency_atomic_units' => null,
        'max_mosaic_atomic_units' => null,
        'total_chain_importance' => null,
        'min_harvester_balance' => null,
        'max_harvester_balance' => null,
        'min_voter_balance' => null,
        'max_voting_keys_per_account' => null,
        'min_voting_key_lifetime' => null,
        'max_voting_key_lifetime' => null,
        'harvest_beneficiary_percentage' => null,
        'harvest_network_percentage' => null,
        'harvest_network_fee_sink_address' => null,
        'block_prune_interval' => null,
        'max_transactions_per_block' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'enable_verifiable_state' => false,
        'enable_verifiable_receipts' => false,
        'currency_mosaic_id' => false,
        'harvesting_mosaic_id' => false,
        'block_generation_target_time' => false,
        'block_time_smoothing_factor' => false,
        'block_finalization_interval' => false,
        'importance_grouping' => false,
        'importance_activity_percentage' => false,
        'max_rollback_blocks' => false,
        'max_difficulty_blocks' => false,
        'default_dynamic_fee_multiplier' => false,
        'max_transaction_lifetime' => false,
        'max_block_future_time' => false,
        'initial_currency_atomic_units' => false,
        'max_mosaic_atomic_units' => false,
        'total_chain_importance' => false,
        'min_harvester_balance' => false,
        'max_harvester_balance' => false,
        'min_voter_balance' => false,
        'max_voting_keys_per_account' => false,
        'min_voting_key_lifetime' => false,
        'max_voting_key_lifetime' => false,
        'harvest_beneficiary_percentage' => false,
        'harvest_network_percentage' => false,
        'harvest_network_fee_sink_address' => false,
        'block_prune_interval' => false,
        'max_transactions_per_block' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'enable_verifiable_state' => 'enableVerifiableState',
        'enable_verifiable_receipts' => 'enableVerifiableReceipts',
        'currency_mosaic_id' => 'currencyMosaicId',
        'harvesting_mosaic_id' => 'harvestingMosaicId',
        'block_generation_target_time' => 'blockGenerationTargetTime',
        'block_time_smoothing_factor' => 'blockTimeSmoothingFactor',
        'block_finalization_interval' => 'blockFinalizationInterval',
        'importance_grouping' => 'importanceGrouping',
        'importance_activity_percentage' => 'importanceActivityPercentage',
        'max_rollback_blocks' => 'maxRollbackBlocks',
        'max_difficulty_blocks' => 'maxDifficultyBlocks',
        'default_dynamic_fee_multiplier' => 'defaultDynamicFeeMultiplier',
        'max_transaction_lifetime' => 'maxTransactionLifetime',
        'max_block_future_time' => 'maxBlockFutureTime',
        'initial_currency_atomic_units' => 'initialCurrencyAtomicUnits',
        'max_mosaic_atomic_units' => 'maxMosaicAtomicUnits',
        'total_chain_importance' => 'totalChainImportance',
        'min_harvester_balance' => 'minHarvesterBalance',
        'max_harvester_balance' => 'maxHarvesterBalance',
        'min_voter_balance' => 'minVoterBalance',
        'max_voting_keys_per_account' => 'maxVotingKeysPerAccount',
        'min_voting_key_lifetime' => 'minVotingKeyLifetime',
        'max_voting_key_lifetime' => 'maxVotingKeyLifetime',
        'harvest_beneficiary_percentage' => 'harvestBeneficiaryPercentage',
        'harvest_network_percentage' => 'harvestNetworkPercentage',
        'harvest_network_fee_sink_address' => 'harvestNetworkFeeSinkAddress',
        'block_prune_interval' => 'blockPruneInterval',
        'max_transactions_per_block' => 'maxTransactionsPerBlock'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'enable_verifiable_state' => 'setEnableVerifiableState',
        'enable_verifiable_receipts' => 'setEnableVerifiableReceipts',
        'currency_mosaic_id' => 'setCurrencyMosaicId',
        'harvesting_mosaic_id' => 'setHarvestingMosaicId',
        'block_generation_target_time' => 'setBlockGenerationTargetTime',
        'block_time_smoothing_factor' => 'setBlockTimeSmoothingFactor',
        'block_finalization_interval' => 'setBlockFinalizationInterval',
        'importance_grouping' => 'setImportanceGrouping',
        'importance_activity_percentage' => 'setImportanceActivityPercentage',
        'max_rollback_blocks' => 'setMaxRollbackBlocks',
        'max_difficulty_blocks' => 'setMaxDifficultyBlocks',
        'default_dynamic_fee_multiplier' => 'setDefaultDynamicFeeMultiplier',
        'max_transaction_lifetime' => 'setMaxTransactionLifetime',
        'max_block_future_time' => 'setMaxBlockFutureTime',
        'initial_currency_atomic_units' => 'setInitialCurrencyAtomicUnits',
        'max_mosaic_atomic_units' => 'setMaxMosaicAtomicUnits',
        'total_chain_importance' => 'setTotalChainImportance',
        'min_harvester_balance' => 'setMinHarvesterBalance',
        'max_harvester_balance' => 'setMaxHarvesterBalance',
        'min_voter_balance' => 'setMinVoterBalance',
        'max_voting_keys_per_account' => 'setMaxVotingKeysPerAccount',
        'min_voting_key_lifetime' => 'setMinVotingKeyLifetime',
        'max_voting_key_lifetime' => 'setMaxVotingKeyLifetime',
        'harvest_beneficiary_percentage' => 'setHarvestBeneficiaryPercentage',
        'harvest_network_percentage' => 'setHarvestNetworkPercentage',
        'harvest_network_fee_sink_address' => 'setHarvestNetworkFeeSinkAddress',
        'block_prune_interval' => 'setBlockPruneInterval',
        'max_transactions_per_block' => 'setMaxTransactionsPerBlock'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'enable_verifiable_state' => 'getEnableVerifiableState',
        'enable_verifiable_receipts' => 'getEnableVerifiableReceipts',
        'currency_mosaic_id' => 'getCurrencyMosaicId',
        'harvesting_mosaic_id' => 'getHarvestingMosaicId',
        'block_generation_target_time' => 'getBlockGenerationTargetTime',
        'block_time_smoothing_factor' => 'getBlockTimeSmoothingFactor',
        'block_finalization_interval' => 'getBlockFinalizationInterval',
        'importance_grouping' => 'getImportanceGrouping',
        'importance_activity_percentage' => 'getImportanceActivityPercentage',
        'max_rollback_blocks' => 'getMaxRollbackBlocks',
        'max_difficulty_blocks' => 'getMaxDifficultyBlocks',
        'default_dynamic_fee_multiplier' => 'getDefaultDynamicFeeMultiplier',
        'max_transaction_lifetime' => 'getMaxTransactionLifetime',
        'max_block_future_time' => 'getMaxBlockFutureTime',
        'initial_currency_atomic_units' => 'getInitialCurrencyAtomicUnits',
        'max_mosaic_atomic_units' => 'getMaxMosaicAtomicUnits',
        'total_chain_importance' => 'getTotalChainImportance',
        'min_harvester_balance' => 'getMinHarvesterBalance',
        'max_harvester_balance' => 'getMaxHarvesterBalance',
        'min_voter_balance' => 'getMinVoterBalance',
        'max_voting_keys_per_account' => 'getMaxVotingKeysPerAccount',
        'min_voting_key_lifetime' => 'getMinVotingKeyLifetime',
        'max_voting_key_lifetime' => 'getMaxVotingKeyLifetime',
        'harvest_beneficiary_percentage' => 'getHarvestBeneficiaryPercentage',
        'harvest_network_percentage' => 'getHarvestNetworkPercentage',
        'harvest_network_fee_sink_address' => 'getHarvestNetworkFeeSinkAddress',
        'block_prune_interval' => 'getBlockPruneInterval',
        'max_transactions_per_block' => 'getMaxTransactionsPerBlock'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('enable_verifiable_state', $data ?? [], null);
        $this->setIfExists('enable_verifiable_receipts', $data ?? [], null);
        $this->setIfExists('currency_mosaic_id', $data ?? [], null);
        $this->setIfExists('harvesting_mosaic_id', $data ?? [], null);
        $this->setIfExists('block_generation_target_time', $data ?? [], null);
        $this->setIfExists('block_time_smoothing_factor', $data ?? [], null);
        $this->setIfExists('block_finalization_interval', $data ?? [], null);
        $this->setIfExists('importance_grouping', $data ?? [], null);
        $this->setIfExists('importance_activity_percentage', $data ?? [], null);
        $this->setIfExists('max_rollback_blocks', $data ?? [], null);
        $this->setIfExists('max_difficulty_blocks', $data ?? [], null);
        $this->setIfExists('default_dynamic_fee_multiplier', $data ?? [], null);
        $this->setIfExists('max_transaction_lifetime', $data ?? [], null);
        $this->setIfExists('max_block_future_time', $data ?? [], null);
        $this->setIfExists('initial_currency_atomic_units', $data ?? [], null);
        $this->setIfExists('max_mosaic_atomic_units', $data ?? [], null);
        $this->setIfExists('total_chain_importance', $data ?? [], null);
        $this->setIfExists('min_harvester_balance', $data ?? [], null);
        $this->setIfExists('max_harvester_balance', $data ?? [], null);
        $this->setIfExists('min_voter_balance', $data ?? [], null);
        $this->setIfExists('max_voting_keys_per_account', $data ?? [], null);
        $this->setIfExists('min_voting_key_lifetime', $data ?? [], null);
        $this->setIfExists('max_voting_key_lifetime', $data ?? [], null);
        $this->setIfExists('harvest_beneficiary_percentage', $data ?? [], null);
        $this->setIfExists('harvest_network_percentage', $data ?? [], null);
        $this->setIfExists('harvest_network_fee_sink_address', $data ?? [], null);
        $this->setIfExists('block_prune_interval', $data ?? [], null);
        $this->setIfExists('max_transactions_per_block', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets enable_verifiable_state
     *
     * @return bool|null
     */
    public function getEnableVerifiableState()
    {
        return $this->container['enable_verifiable_state'];
    }

    /**
     * Sets enable_verifiable_state
     *
     * @param bool|null $enable_verifiable_state Set to true if block chain should calculate state hashes so that state is fully verifiable at each block.
     *
     * @return self
     */
    public function setEnableVerifiableState($enable_verifiable_state)
    {
        if (is_null($enable_verifiable_state)) {
            throw new \InvalidArgumentException('non-nullable enable_verifiable_state cannot be null');
        }
        $this->container['enable_verifiable_state'] = $enable_verifiable_state;

        return $this;
    }

    /**
     * Gets enable_verifiable_receipts
     *
     * @return bool|null
     */
    public function getEnableVerifiableReceipts()
    {
        return $this->container['enable_verifiable_receipts'];
    }

    /**
     * Sets enable_verifiable_receipts
     *
     * @param bool|null $enable_verifiable_receipts Set to true if block chain should calculate receipts so that state changes are fully verifiable at each block.
     *
     * @return self
     */
    public function setEnableVerifiableReceipts($enable_verifiable_receipts)
    {
        if (is_null($enable_verifiable_receipts)) {
            throw new \InvalidArgumentException('non-nullable enable_verifiable_receipts cannot be null');
        }
        $this->container['enable_verifiable_receipts'] = $enable_verifiable_receipts;

        return $this;
    }

    /**
     * Gets currency_mosaic_id
     *
     * @return string|null
     */
    public function getCurrencyMosaicId()
    {
        return $this->container['currency_mosaic_id'];
    }

    /**
     * Sets currency_mosaic_id
     *
     * @param string|null $currency_mosaic_id Mosaic id used as primary chain currency.
     *
     * @return self
     */
    public function setCurrencyMosaicId($currency_mosaic_id)
    {
        if (is_null($currency_mosaic_id)) {
            throw new \InvalidArgumentException('non-nullable currency_mosaic_id cannot be null');
        }
        $this->container['currency_mosaic_id'] = $currency_mosaic_id;

        return $this;
    }

    /**
     * Gets harvesting_mosaic_id
     *
     * @return string|null
     */
    public function getHarvestingMosaicId()
    {
        return $this->container['harvesting_mosaic_id'];
    }

    /**
     * Sets harvesting_mosaic_id
     *
     * @param string|null $harvesting_mosaic_id Mosaic id used to provide harvesting ability.
     *
     * @return self
     */
    public function setHarvestingMosaicId($harvesting_mosaic_id)
    {
        if (is_null($harvesting_mosaic_id)) {
            throw new \InvalidArgumentException('non-nullable harvesting_mosaic_id cannot be null');
        }
        $this->container['harvesting_mosaic_id'] = $harvesting_mosaic_id;

        return $this;
    }

    /**
     * Gets block_generation_target_time
     *
     * @return string|null
     */
    public function getBlockGenerationTargetTime()
    {
        return $this->container['block_generation_target_time'];
    }

    /**
     * Sets block_generation_target_time
     *
     * @param string|null $block_generation_target_time Targeted time between blocks.
     *
     * @return self
     */
    public function setBlockGenerationTargetTime($block_generation_target_time)
    {
        if (is_null($block_generation_target_time)) {
            throw new \InvalidArgumentException('non-nullable block_generation_target_time cannot be null');
        }
        $this->container['block_generation_target_time'] = $block_generation_target_time;

        return $this;
    }

    /**
     * Gets block_time_smoothing_factor
     *
     * @return string|null
     */
    public function getBlockTimeSmoothingFactor()
    {
        return $this->container['block_time_smoothing_factor'];
    }

    /**
     * Sets block_time_smoothing_factor
     *
     * @param string|null $block_time_smoothing_factor A higher value makes the network more biased.
     *
     * @return self
     */
    public function setBlockTimeSmoothingFactor($block_time_smoothing_factor)
    {
        if (is_null($block_time_smoothing_factor)) {
            throw new \InvalidArgumentException('non-nullable block_time_smoothing_factor cannot be null');
        }
        $this->container['block_time_smoothing_factor'] = $block_time_smoothing_factor;

        return $this;
    }

    /**
     * Gets block_finalization_interval
     *
     * @return string|null
     */
    public function getBlockFinalizationInterval()
    {
        return $this->container['block_finalization_interval'];
    }

    /**
     * Sets block_finalization_interval
     *
     * @param string|null $block_finalization_interval Number of blocks between successive finalization attempts.
     *
     * @return self
     */
    public function setBlockFinalizationInterval($block_finalization_interval)
    {
        if (is_null($block_finalization_interval)) {
            throw new \InvalidArgumentException('non-nullable block_finalization_interval cannot be null');
        }
        $this->container['block_finalization_interval'] = $block_finalization_interval;

        return $this;
    }

    /**
     * Gets importance_grouping
     *
     * @return string|null
     */
    public function getImportanceGrouping()
    {
        return $this->container['importance_grouping'];
    }

    /**
     * Sets importance_grouping
     *
     * @param string|null $importance_grouping Number of blocks that should be treated as a group for importance purposes.
     *
     * @return self
     */
    public function setImportanceGrouping($importance_grouping)
    {
        if (is_null($importance_grouping)) {
            throw new \InvalidArgumentException('non-nullable importance_grouping cannot be null');
        }
        $this->container['importance_grouping'] = $importance_grouping;

        return $this;
    }

    /**
     * Gets importance_activity_percentage
     *
     * @return string|null
     */
    public function getImportanceActivityPercentage()
    {
        return $this->container['importance_activity_percentage'];
    }

    /**
     * Sets importance_activity_percentage
     *
     * @param string|null $importance_activity_percentage Percentage of importance resulting from fee generation and beneficiary usage.
     *
     * @return self
     */
    public function setImportanceActivityPercentage($importance_activity_percentage)
    {
        if (is_null($importance_activity_percentage)) {
            throw new \InvalidArgumentException('non-nullable importance_activity_percentage cannot be null');
        }
        $this->container['importance_activity_percentage'] = $importance_activity_percentage;

        return $this;
    }

    /**
     * Gets max_rollback_blocks
     *
     * @return string|null
     */
    public function getMaxRollbackBlocks()
    {
        return $this->container['max_rollback_blocks'];
    }

    /**
     * Sets max_rollback_blocks
     *
     * @param string|null $max_rollback_blocks Maximum number of blocks that can be rolled back.
     *
     * @return self
     */
    public function setMaxRollbackBlocks($max_rollback_blocks)
    {
        if (is_null($max_rollback_blocks)) {
            throw new \InvalidArgumentException('non-nullable max_rollback_blocks cannot be null');
        }
        $this->container['max_rollback_blocks'] = $max_rollback_blocks;

        return $this;
    }

    /**
     * Gets max_difficulty_blocks
     *
     * @return string|null
     */
    public function getMaxDifficultyBlocks()
    {
        return $this->container['max_difficulty_blocks'];
    }

    /**
     * Sets max_difficulty_blocks
     *
     * @param string|null $max_difficulty_blocks Maximum number of blocks to use in a difficulty calculation.
     *
     * @return self
     */
    public function setMaxDifficultyBlocks($max_difficulty_blocks)
    {
        if (is_null($max_difficulty_blocks)) {
            throw new \InvalidArgumentException('non-nullable max_difficulty_blocks cannot be null');
        }
        $this->container['max_difficulty_blocks'] = $max_difficulty_blocks;

        return $this;
    }

    /**
     * Gets default_dynamic_fee_multiplier
     *
     * @return string|null
     */
    public function getDefaultDynamicFeeMultiplier()
    {
        return $this->container['default_dynamic_fee_multiplier'];
    }

    /**
     * Sets default_dynamic_fee_multiplier
     *
     * @param string|null $default_dynamic_fee_multiplier Default multiplier to use for dynamic fees.
     *
     * @return self
     */
    public function setDefaultDynamicFeeMultiplier($default_dynamic_fee_multiplier)
    {
        if (is_null($default_dynamic_fee_multiplier)) {
            throw new \InvalidArgumentException('non-nullable default_dynamic_fee_multiplier cannot be null');
        }
        $this->container['default_dynamic_fee_multiplier'] = $default_dynamic_fee_multiplier;

        return $this;
    }

    /**
     * Gets max_transaction_lifetime
     *
     * @return string|null
     */
    public function getMaxTransactionLifetime()
    {
        return $this->container['max_transaction_lifetime'];
    }

    /**
     * Sets max_transaction_lifetime
     *
     * @param string|null $max_transaction_lifetime Maximum lifetime a transaction can have before it expires.
     *
     * @return self
     */
    public function setMaxTransactionLifetime($max_transaction_lifetime)
    {
        if (is_null($max_transaction_lifetime)) {
            throw new \InvalidArgumentException('non-nullable max_transaction_lifetime cannot be null');
        }
        $this->container['max_transaction_lifetime'] = $max_transaction_lifetime;

        return $this;
    }

    /**
     * Gets max_block_future_time
     *
     * @return string|null
     */
    public function getMaxBlockFutureTime()
    {
        return $this->container['max_block_future_time'];
    }

    /**
     * Sets max_block_future_time
     *
     * @param string|null $max_block_future_time Maximum future time of a block that can be accepted.
     *
     * @return self
     */
    public function setMaxBlockFutureTime($max_block_future_time)
    {
        if (is_null($max_block_future_time)) {
            throw new \InvalidArgumentException('non-nullable max_block_future_time cannot be null');
        }
        $this->container['max_block_future_time'] = $max_block_future_time;

        return $this;
    }

    /**
     * Gets initial_currency_atomic_units
     *
     * @return string|null
     */
    public function getInitialCurrencyAtomicUnits()
    {
        return $this->container['initial_currency_atomic_units'];
    }

    /**
     * Sets initial_currency_atomic_units
     *
     * @param string|null $initial_currency_atomic_units Initial currency atomic units available in the network.
     *
     * @return self
     */
    public function setInitialCurrencyAtomicUnits($initial_currency_atomic_units)
    {
        if (is_null($initial_currency_atomic_units)) {
            throw new \InvalidArgumentException('non-nullable initial_currency_atomic_units cannot be null');
        }
        $this->container['initial_currency_atomic_units'] = $initial_currency_atomic_units;

        return $this;
    }

    /**
     * Gets max_mosaic_atomic_units
     *
     * @return string|null
     */
    public function getMaxMosaicAtomicUnits()
    {
        return $this->container['max_mosaic_atomic_units'];
    }

    /**
     * Sets max_mosaic_atomic_units
     *
     * @param string|null $max_mosaic_atomic_units Maximum atomic units (total-supply * 10 ^ divisibility) of a mosaic allowed in the network.
     *
     * @return self
     */
    public function setMaxMosaicAtomicUnits($max_mosaic_atomic_units)
    {
        if (is_null($max_mosaic_atomic_units)) {
            throw new \InvalidArgumentException('non-nullable max_mosaic_atomic_units cannot be null');
        }
        $this->container['max_mosaic_atomic_units'] = $max_mosaic_atomic_units;

        return $this;
    }

    /**
     * Gets total_chain_importance
     *
     * @return string|null
     */
    public function getTotalChainImportance()
    {
        return $this->container['total_chain_importance'];
    }

    /**
     * Sets total_chain_importance
     *
     * @param string|null $total_chain_importance Total whole importance units available in the network.
     *
     * @return self
     */
    public function setTotalChainImportance($total_chain_importance)
    {
        if (is_null($total_chain_importance)) {
            throw new \InvalidArgumentException('non-nullable total_chain_importance cannot be null');
        }
        $this->container['total_chain_importance'] = $total_chain_importance;

        return $this;
    }

    /**
     * Gets min_harvester_balance
     *
     * @return string|null
     */
    public function getMinHarvesterBalance()
    {
        return $this->container['min_harvester_balance'];
    }

    /**
     * Sets min_harvester_balance
     *
     * @param string|null $min_harvester_balance Minimum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.
     *
     * @return self
     */
    public function setMinHarvesterBalance($min_harvester_balance)
    {
        if (is_null($min_harvester_balance)) {
            throw new \InvalidArgumentException('non-nullable min_harvester_balance cannot be null');
        }
        $this->container['min_harvester_balance'] = $min_harvester_balance;

        return $this;
    }

    /**
     * Gets max_harvester_balance
     *
     * @return string|null
     */
    public function getMaxHarvesterBalance()
    {
        return $this->container['max_harvester_balance'];
    }

    /**
     * Sets max_harvester_balance
     *
     * @param string|null $max_harvester_balance Maximum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.
     *
     * @return self
     */
    public function setMaxHarvesterBalance($max_harvester_balance)
    {
        if (is_null($max_harvester_balance)) {
            throw new \InvalidArgumentException('non-nullable max_harvester_balance cannot be null');
        }
        $this->container['max_harvester_balance'] = $max_harvester_balance;

        return $this;
    }

    /**
     * Gets min_voter_balance
     *
     * @return string|null
     */
    public function getMinVoterBalance()
    {
        return $this->container['min_voter_balance'];
    }

    /**
     * Sets min_voter_balance
     *
     * @param string|null $min_voter_balance Minimum number of harvesting mosaic atomic units needed for an account to be eligible for voting.
     *
     * @return self
     */
    public function setMinVoterBalance($min_voter_balance)
    {
        if (is_null($min_voter_balance)) {
            throw new \InvalidArgumentException('non-nullable min_voter_balance cannot be null');
        }
        $this->container['min_voter_balance'] = $min_voter_balance;

        return $this;
    }

    /**
     * Gets max_voting_keys_per_account
     *
     * @return string|null
     */
    public function getMaxVotingKeysPerAccount()
    {
        return $this->container['max_voting_keys_per_account'];
    }

    /**
     * Sets max_voting_keys_per_account
     *
     * @param string|null $max_voting_keys_per_account Maximum number of voting keys that can be registered at once per account.
     *
     * @return self
     */
    public function setMaxVotingKeysPerAccount($max_voting_keys_per_account)
    {
        if (is_null($max_voting_keys_per_account)) {
            throw new \InvalidArgumentException('non-nullable max_voting_keys_per_account cannot be null');
        }
        $this->container['max_voting_keys_per_account'] = $max_voting_keys_per_account;

        return $this;
    }

    /**
     * Gets min_voting_key_lifetime
     *
     * @return string|null
     */
    public function getMinVotingKeyLifetime()
    {
        return $this->container['min_voting_key_lifetime'];
    }

    /**
     * Sets min_voting_key_lifetime
     *
     * @param string|null $min_voting_key_lifetime Minimum number of finalization rounds for which voting key can be registered.
     *
     * @return self
     */
    public function setMinVotingKeyLifetime($min_voting_key_lifetime)
    {
        if (is_null($min_voting_key_lifetime)) {
            throw new \InvalidArgumentException('non-nullable min_voting_key_lifetime cannot be null');
        }
        $this->container['min_voting_key_lifetime'] = $min_voting_key_lifetime;

        return $this;
    }

    /**
     * Gets max_voting_key_lifetime
     *
     * @return string|null
     */
    public function getMaxVotingKeyLifetime()
    {
        return $this->container['max_voting_key_lifetime'];
    }

    /**
     * Sets max_voting_key_lifetime
     *
     * @param string|null $max_voting_key_lifetime Maximum number of finalization rounds for which voting key can be registered.
     *
     * @return self
     */
    public function setMaxVotingKeyLifetime($max_voting_key_lifetime)
    {
        if (is_null($max_voting_key_lifetime)) {
            throw new \InvalidArgumentException('non-nullable max_voting_key_lifetime cannot be null');
        }
        $this->container['max_voting_key_lifetime'] = $max_voting_key_lifetime;

        return $this;
    }

    /**
     * Gets harvest_beneficiary_percentage
     *
     * @return string|null
     */
    public function getHarvestBeneficiaryPercentage()
    {
        return $this->container['harvest_beneficiary_percentage'];
    }

    /**
     * Sets harvest_beneficiary_percentage
     *
     * @param string|null $harvest_beneficiary_percentage Percentage of the harvested fee that is collected by the beneficiary account.
     *
     * @return self
     */
    public function setHarvestBeneficiaryPercentage($harvest_beneficiary_percentage)
    {
        if (is_null($harvest_beneficiary_percentage)) {
            throw new \InvalidArgumentException('non-nullable harvest_beneficiary_percentage cannot be null');
        }
        $this->container['harvest_beneficiary_percentage'] = $harvest_beneficiary_percentage;

        return $this;
    }

    /**
     * Gets harvest_network_percentage
     *
     * @return string|null
     */
    public function getHarvestNetworkPercentage()
    {
        return $this->container['harvest_network_percentage'];
    }

    /**
     * Sets harvest_network_percentage
     *
     * @param string|null $harvest_network_percentage Percentage of the harvested fee that is collected by the network.
     *
     * @return self
     */
    public function setHarvestNetworkPercentage($harvest_network_percentage)
    {
        if (is_null($harvest_network_percentage)) {
            throw new \InvalidArgumentException('non-nullable harvest_network_percentage cannot be null');
        }
        $this->container['harvest_network_percentage'] = $harvest_network_percentage;

        return $this;
    }

    /**
     * Gets harvest_network_fee_sink_address
     *
     * @return string|null
     */
    public function getHarvestNetworkFeeSinkAddress()
    {
        return $this->container['harvest_network_fee_sink_address'];
    }

    /**
     * Sets harvest_network_fee_sink_address
     *
     * @param string|null $harvest_network_fee_sink_address Address encoded using a 32-character set.
     *
     * @return self
     */
    public function setHarvestNetworkFeeSinkAddress($harvest_network_fee_sink_address)
    {
        if (is_null($harvest_network_fee_sink_address)) {
            throw new \InvalidArgumentException('non-nullable harvest_network_fee_sink_address cannot be null');
        }
        $this->container['harvest_network_fee_sink_address'] = $harvest_network_fee_sink_address;

        return $this;
    }

    /**
     * Gets block_prune_interval
     *
     * @return string|null
     */
    public function getBlockPruneInterval()
    {
        return $this->container['block_prune_interval'];
    }

    /**
     * Sets block_prune_interval
     *
     * @param string|null $block_prune_interval Number of blocks between cache pruning.
     *
     * @return self
     */
    public function setBlockPruneInterval($block_prune_interval)
    {
        if (is_null($block_prune_interval)) {
            throw new \InvalidArgumentException('non-nullable block_prune_interval cannot be null');
        }
        $this->container['block_prune_interval'] = $block_prune_interval;

        return $this;
    }

    /**
     * Gets max_transactions_per_block
     *
     * @return string|null
     */
    public function getMaxTransactionsPerBlock()
    {
        return $this->container['max_transactions_per_block'];
    }

    /**
     * Sets max_transactions_per_block
     *
     * @param string|null $max_transactions_per_block Maximum number of transactions per block.
     *
     * @return self
     */
    public function setMaxTransactionsPerBlock($max_transactions_per_block)
    {
        if (is_null($max_transactions_per_block)) {
            throw new \InvalidArgumentException('non-nullable max_transactions_per_block cannot be null');
        }
        $this->container['max_transactions_per_block'] = $max_transactions_per_block;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


