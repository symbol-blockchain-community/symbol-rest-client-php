<?php
/**
 * TransactionInfoDTOTransaction
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  SymbolRestClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Catapult REST Endpoints
 *
 * OpenAPI Specification of catapult-rest
 *
 * The version of the OpenAPI document: 1.0.4
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.2.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SymbolRestClient\Model;

use \ArrayAccess;
use \SymbolRestClient\ObjectSerializer;

/**
 * TransactionInfoDTOTransaction Class Doc Comment
 *
 * @category Class
 * @package  SymbolRestClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class TransactionInfoDTOTransaction implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'TransactionInfoDTO_transaction';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'size' => 'int',
        'signature' => 'string',
        'signer_public_key' => 'string',
        'version' => 'int',
        'network' => '\SymbolRestClient\Model\NetworkTypeEnum',
        'type' => 'int',
        'max_fee' => 'string',
        'deadline' => 'string',
        'linked_public_key' => 'string',
        'link_action' => '\SymbolRestClient\Model\LinkActionEnum',
        'start_epoch' => 'int',
        'end_epoch' => 'int',
        'transactions_hash' => 'string',
        'cosignatures' => '\SymbolRestClient\Model\CosignatureDTO[]',
        'transactions' => '\SymbolRestClient\Model\EmbeddedTransactionInfoDTO[]',
        'mosaic_id' => 'string',
        'amount' => 'string',
        'duration' => 'string',
        'hash' => 'string',
        'recipient_address' => 'string',
        'secret' => 'string',
        'hash_algorithm' => '\SymbolRestClient\Model\LockHashAlgorithmEnum',
        'proof' => 'string',
        'target_address' => 'string',
        'scoped_metadata_key' => 'string',
        'value_size_delta' => 'int',
        'value_size' => 'int',
        'value' => 'string',
        'target_mosaic_id' => 'string',
        'target_namespace_id' => 'string',
        'id' => 'string',
        'nonce' => 'int',
        'flags' => 'int',
        'divisibility' => 'int',
        'delta' => 'string',
        'action' => '\SymbolRestClient\Model\MosaicSupplyChangeActionEnum',
        'source_address' => 'string',
        'parent_id' => 'string',
        'registration_type' => '\SymbolRestClient\Model\NamespaceRegistrationTypeEnum',
        'name' => 'string',
        'namespace_id' => 'string',
        'address' => 'string',
        'alias_action' => '\SymbolRestClient\Model\AliasActionEnum',
        'min_removal_delta' => 'int',
        'min_approval_delta' => 'int',
        'address_additions' => 'string[]',
        'address_deletions' => 'string[]',
        'restriction_flags' => '\SymbolRestClient\Model\AccountRestrictionFlagsEnum',
        'restriction_additions' => '\SymbolRestClient\Model\TransactionTypeEnum[]',
        'restriction_deletions' => '\SymbolRestClient\Model\TransactionTypeEnum[]',
        'reference_mosaic_id' => 'string',
        'restriction_key' => 'string',
        'previous_restriction_value' => 'string',
        'new_restriction_value' => 'string',
        'previous_restriction_type' => '\SymbolRestClient\Model\MosaicRestrictionTypeEnum',
        'new_restriction_type' => '\SymbolRestClient\Model\MosaicRestrictionTypeEnum',
        'mosaics' => '\SymbolRestClient\Model\UnresolvedMosaic[]',
        'message' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'size' => 'int64',
        'signature' => null,
        'signer_public_key' => 'hex',
        'version' => null,
        'network' => null,
        'type' => null,
        'max_fee' => null,
        'deadline' => null,
        'linked_public_key' => 'hex',
        'link_action' => null,
        'start_epoch' => 'int64',
        'end_epoch' => 'int64',
        'transactions_hash' => 'hex',
        'cosignatures' => null,
        'transactions' => null,
        'mosaic_id' => 'hex',
        'amount' => null,
        'duration' => null,
        'hash' => 'hex',
        'recipient_address' => null,
        'secret' => 'hex',
        'hash_algorithm' => null,
        'proof' => null,
        'target_address' => null,
        'scoped_metadata_key' => 'hex',
        'value_size_delta' => null,
        'value_size' => 'int64',
        'value' => 'hex',
        'target_mosaic_id' => 'hex',
        'target_namespace_id' => 'hex',
        'id' => 'hex',
        'nonce' => 'int64',
        'flags' => null,
        'divisibility' => null,
        'delta' => null,
        'action' => null,
        'source_address' => null,
        'parent_id' => 'hex',
        'registration_type' => null,
        'name' => null,
        'namespace_id' => 'hex',
        'address' => null,
        'alias_action' => null,
        'min_removal_delta' => null,
        'min_approval_delta' => null,
        'address_additions' => null,
        'address_deletions' => null,
        'restriction_flags' => null,
        'restriction_additions' => null,
        'restriction_deletions' => null,
        'reference_mosaic_id' => 'hex',
        'restriction_key' => 'hex',
        'previous_restriction_value' => null,
        'new_restriction_value' => null,
        'previous_restriction_type' => null,
        'new_restriction_type' => null,
        'mosaics' => null,
        'message' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'size' => false,
        'signature' => false,
        'signer_public_key' => false,
        'version' => false,
        'network' => false,
        'type' => false,
        'max_fee' => false,
        'deadline' => false,
        'linked_public_key' => false,
        'link_action' => false,
        'start_epoch' => false,
        'end_epoch' => false,
        'transactions_hash' => false,
        'cosignatures' => false,
        'transactions' => false,
        'mosaic_id' => false,
        'amount' => false,
        'duration' => false,
        'hash' => false,
        'recipient_address' => false,
        'secret' => false,
        'hash_algorithm' => false,
        'proof' => false,
        'target_address' => false,
        'scoped_metadata_key' => false,
        'value_size_delta' => false,
        'value_size' => false,
        'value' => false,
        'target_mosaic_id' => false,
        'target_namespace_id' => false,
        'id' => false,
        'nonce' => false,
        'flags' => false,
        'divisibility' => false,
        'delta' => false,
        'action' => false,
        'source_address' => false,
        'parent_id' => false,
        'registration_type' => false,
        'name' => false,
        'namespace_id' => false,
        'address' => false,
        'alias_action' => false,
        'min_removal_delta' => false,
        'min_approval_delta' => false,
        'address_additions' => false,
        'address_deletions' => false,
        'restriction_flags' => false,
        'restriction_additions' => false,
        'restriction_deletions' => false,
        'reference_mosaic_id' => false,
        'restriction_key' => false,
        'previous_restriction_value' => false,
        'new_restriction_value' => false,
        'previous_restriction_type' => false,
        'new_restriction_type' => false,
        'mosaics' => false,
        'message' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'size' => 'size',
        'signature' => 'signature',
        'signer_public_key' => 'signerPublicKey',
        'version' => 'version',
        'network' => 'network',
        'type' => 'type',
        'max_fee' => 'maxFee',
        'deadline' => 'deadline',
        'linked_public_key' => 'linkedPublicKey',
        'link_action' => 'linkAction',
        'start_epoch' => 'startEpoch',
        'end_epoch' => 'endEpoch',
        'transactions_hash' => 'transactionsHash',
        'cosignatures' => 'cosignatures',
        'transactions' => 'transactions',
        'mosaic_id' => 'mosaicId',
        'amount' => 'amount',
        'duration' => 'duration',
        'hash' => 'hash',
        'recipient_address' => 'recipientAddress',
        'secret' => 'secret',
        'hash_algorithm' => 'hashAlgorithm',
        'proof' => 'proof',
        'target_address' => 'targetAddress',
        'scoped_metadata_key' => 'scopedMetadataKey',
        'value_size_delta' => 'valueSizeDelta',
        'value_size' => 'valueSize',
        'value' => 'value',
        'target_mosaic_id' => 'targetMosaicId',
        'target_namespace_id' => 'targetNamespaceId',
        'id' => 'id',
        'nonce' => 'nonce',
        'flags' => 'flags',
        'divisibility' => 'divisibility',
        'delta' => 'delta',
        'action' => 'action',
        'source_address' => 'sourceAddress',
        'parent_id' => 'parentId',
        'registration_type' => 'registrationType',
        'name' => 'name',
        'namespace_id' => 'namespaceId',
        'address' => 'address',
        'alias_action' => 'aliasAction',
        'min_removal_delta' => 'minRemovalDelta',
        'min_approval_delta' => 'minApprovalDelta',
        'address_additions' => 'addressAdditions',
        'address_deletions' => 'addressDeletions',
        'restriction_flags' => 'restrictionFlags',
        'restriction_additions' => 'restrictionAdditions',
        'restriction_deletions' => 'restrictionDeletions',
        'reference_mosaic_id' => 'referenceMosaicId',
        'restriction_key' => 'restrictionKey',
        'previous_restriction_value' => 'previousRestrictionValue',
        'new_restriction_value' => 'newRestrictionValue',
        'previous_restriction_type' => 'previousRestrictionType',
        'new_restriction_type' => 'newRestrictionType',
        'mosaics' => 'mosaics',
        'message' => 'message'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'size' => 'setSize',
        'signature' => 'setSignature',
        'signer_public_key' => 'setSignerPublicKey',
        'version' => 'setVersion',
        'network' => 'setNetwork',
        'type' => 'setType',
        'max_fee' => 'setMaxFee',
        'deadline' => 'setDeadline',
        'linked_public_key' => 'setLinkedPublicKey',
        'link_action' => 'setLinkAction',
        'start_epoch' => 'setStartEpoch',
        'end_epoch' => 'setEndEpoch',
        'transactions_hash' => 'setTransactionsHash',
        'cosignatures' => 'setCosignatures',
        'transactions' => 'setTransactions',
        'mosaic_id' => 'setMosaicId',
        'amount' => 'setAmount',
        'duration' => 'setDuration',
        'hash' => 'setHash',
        'recipient_address' => 'setRecipientAddress',
        'secret' => 'setSecret',
        'hash_algorithm' => 'setHashAlgorithm',
        'proof' => 'setProof',
        'target_address' => 'setTargetAddress',
        'scoped_metadata_key' => 'setScopedMetadataKey',
        'value_size_delta' => 'setValueSizeDelta',
        'value_size' => 'setValueSize',
        'value' => 'setValue',
        'target_mosaic_id' => 'setTargetMosaicId',
        'target_namespace_id' => 'setTargetNamespaceId',
        'id' => 'setId',
        'nonce' => 'setNonce',
        'flags' => 'setFlags',
        'divisibility' => 'setDivisibility',
        'delta' => 'setDelta',
        'action' => 'setAction',
        'source_address' => 'setSourceAddress',
        'parent_id' => 'setParentId',
        'registration_type' => 'setRegistrationType',
        'name' => 'setName',
        'namespace_id' => 'setNamespaceId',
        'address' => 'setAddress',
        'alias_action' => 'setAliasAction',
        'min_removal_delta' => 'setMinRemovalDelta',
        'min_approval_delta' => 'setMinApprovalDelta',
        'address_additions' => 'setAddressAdditions',
        'address_deletions' => 'setAddressDeletions',
        'restriction_flags' => 'setRestrictionFlags',
        'restriction_additions' => 'setRestrictionAdditions',
        'restriction_deletions' => 'setRestrictionDeletions',
        'reference_mosaic_id' => 'setReferenceMosaicId',
        'restriction_key' => 'setRestrictionKey',
        'previous_restriction_value' => 'setPreviousRestrictionValue',
        'new_restriction_value' => 'setNewRestrictionValue',
        'previous_restriction_type' => 'setPreviousRestrictionType',
        'new_restriction_type' => 'setNewRestrictionType',
        'mosaics' => 'setMosaics',
        'message' => 'setMessage'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'size' => 'getSize',
        'signature' => 'getSignature',
        'signer_public_key' => 'getSignerPublicKey',
        'version' => 'getVersion',
        'network' => 'getNetwork',
        'type' => 'getType',
        'max_fee' => 'getMaxFee',
        'deadline' => 'getDeadline',
        'linked_public_key' => 'getLinkedPublicKey',
        'link_action' => 'getLinkAction',
        'start_epoch' => 'getStartEpoch',
        'end_epoch' => 'getEndEpoch',
        'transactions_hash' => 'getTransactionsHash',
        'cosignatures' => 'getCosignatures',
        'transactions' => 'getTransactions',
        'mosaic_id' => 'getMosaicId',
        'amount' => 'getAmount',
        'duration' => 'getDuration',
        'hash' => 'getHash',
        'recipient_address' => 'getRecipientAddress',
        'secret' => 'getSecret',
        'hash_algorithm' => 'getHashAlgorithm',
        'proof' => 'getProof',
        'target_address' => 'getTargetAddress',
        'scoped_metadata_key' => 'getScopedMetadataKey',
        'value_size_delta' => 'getValueSizeDelta',
        'value_size' => 'getValueSize',
        'value' => 'getValue',
        'target_mosaic_id' => 'getTargetMosaicId',
        'target_namespace_id' => 'getTargetNamespaceId',
        'id' => 'getId',
        'nonce' => 'getNonce',
        'flags' => 'getFlags',
        'divisibility' => 'getDivisibility',
        'delta' => 'getDelta',
        'action' => 'getAction',
        'source_address' => 'getSourceAddress',
        'parent_id' => 'getParentId',
        'registration_type' => 'getRegistrationType',
        'name' => 'getName',
        'namespace_id' => 'getNamespaceId',
        'address' => 'getAddress',
        'alias_action' => 'getAliasAction',
        'min_removal_delta' => 'getMinRemovalDelta',
        'min_approval_delta' => 'getMinApprovalDelta',
        'address_additions' => 'getAddressAdditions',
        'address_deletions' => 'getAddressDeletions',
        'restriction_flags' => 'getRestrictionFlags',
        'restriction_additions' => 'getRestrictionAdditions',
        'restriction_deletions' => 'getRestrictionDeletions',
        'reference_mosaic_id' => 'getReferenceMosaicId',
        'restriction_key' => 'getRestrictionKey',
        'previous_restriction_value' => 'getPreviousRestrictionValue',
        'new_restriction_value' => 'getNewRestrictionValue',
        'previous_restriction_type' => 'getPreviousRestrictionType',
        'new_restriction_type' => 'getNewRestrictionType',
        'mosaics' => 'getMosaics',
        'message' => 'getMessage'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('size', $data ?? [], null);
        $this->setIfExists('signature', $data ?? [], null);
        $this->setIfExists('signer_public_key', $data ?? [], null);
        $this->setIfExists('version', $data ?? [], null);
        $this->setIfExists('network', $data ?? [], null);
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('max_fee', $data ?? [], null);
        $this->setIfExists('deadline', $data ?? [], null);
        $this->setIfExists('linked_public_key', $data ?? [], null);
        $this->setIfExists('link_action', $data ?? [], null);
        $this->setIfExists('start_epoch', $data ?? [], null);
        $this->setIfExists('end_epoch', $data ?? [], null);
        $this->setIfExists('transactions_hash', $data ?? [], null);
        $this->setIfExists('cosignatures', $data ?? [], null);
        $this->setIfExists('transactions', $data ?? [], null);
        $this->setIfExists('mosaic_id', $data ?? [], null);
        $this->setIfExists('amount', $data ?? [], null);
        $this->setIfExists('duration', $data ?? [], null);
        $this->setIfExists('hash', $data ?? [], null);
        $this->setIfExists('recipient_address', $data ?? [], null);
        $this->setIfExists('secret', $data ?? [], null);
        $this->setIfExists('hash_algorithm', $data ?? [], null);
        $this->setIfExists('proof', $data ?? [], null);
        $this->setIfExists('target_address', $data ?? [], null);
        $this->setIfExists('scoped_metadata_key', $data ?? [], null);
        $this->setIfExists('value_size_delta', $data ?? [], null);
        $this->setIfExists('value_size', $data ?? [], null);
        $this->setIfExists('value', $data ?? [], null);
        $this->setIfExists('target_mosaic_id', $data ?? [], null);
        $this->setIfExists('target_namespace_id', $data ?? [], null);
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('nonce', $data ?? [], null);
        $this->setIfExists('flags', $data ?? [], null);
        $this->setIfExists('divisibility', $data ?? [], null);
        $this->setIfExists('delta', $data ?? [], null);
        $this->setIfExists('action', $data ?? [], null);
        $this->setIfExists('source_address', $data ?? [], null);
        $this->setIfExists('parent_id', $data ?? [], null);
        $this->setIfExists('registration_type', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('namespace_id', $data ?? [], null);
        $this->setIfExists('address', $data ?? [], null);
        $this->setIfExists('alias_action', $data ?? [], null);
        $this->setIfExists('min_removal_delta', $data ?? [], null);
        $this->setIfExists('min_approval_delta', $data ?? [], null);
        $this->setIfExists('address_additions', $data ?? [], null);
        $this->setIfExists('address_deletions', $data ?? [], null);
        $this->setIfExists('restriction_flags', $data ?? [], null);
        $this->setIfExists('restriction_additions', $data ?? [], null);
        $this->setIfExists('restriction_deletions', $data ?? [], null);
        $this->setIfExists('reference_mosaic_id', $data ?? [], null);
        $this->setIfExists('restriction_key', $data ?? [], null);
        $this->setIfExists('previous_restriction_value', $data ?? [], null);
        $this->setIfExists('new_restriction_value', $data ?? [], null);
        $this->setIfExists('previous_restriction_type', $data ?? [], null);
        $this->setIfExists('new_restriction_type', $data ?? [], null);
        $this->setIfExists('mosaics', $data ?? [], null);
        $this->setIfExists('message', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['size'] === null) {
            $invalidProperties[] = "'size' can't be null";
        }
        if ($this->container['signature'] === null) {
            $invalidProperties[] = "'signature' can't be null";
        }
        if ($this->container['signer_public_key'] === null) {
            $invalidProperties[] = "'signer_public_key' can't be null";
        }
        if ($this->container['version'] === null) {
            $invalidProperties[] = "'version' can't be null";
        }
        if ($this->container['network'] === null) {
            $invalidProperties[] = "'network' can't be null";
        }
        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        if ($this->container['max_fee'] === null) {
            $invalidProperties[] = "'max_fee' can't be null";
        }
        if ($this->container['deadline'] === null) {
            $invalidProperties[] = "'deadline' can't be null";
        }
        if ($this->container['linked_public_key'] === null) {
            $invalidProperties[] = "'linked_public_key' can't be null";
        }
        if ($this->container['link_action'] === null) {
            $invalidProperties[] = "'link_action' can't be null";
        }
        if ($this->container['start_epoch'] === null) {
            $invalidProperties[] = "'start_epoch' can't be null";
        }
        if ($this->container['end_epoch'] === null) {
            $invalidProperties[] = "'end_epoch' can't be null";
        }
        if ($this->container['transactions_hash'] === null) {
            $invalidProperties[] = "'transactions_hash' can't be null";
        }
        if ($this->container['cosignatures'] === null) {
            $invalidProperties[] = "'cosignatures' can't be null";
        }
        if ($this->container['transactions'] === null) {
            $invalidProperties[] = "'transactions' can't be null";
        }
        if ($this->container['mosaic_id'] === null) {
            $invalidProperties[] = "'mosaic_id' can't be null";
        }
        if ($this->container['amount'] === null) {
            $invalidProperties[] = "'amount' can't be null";
        }
        if ($this->container['duration'] === null) {
            $invalidProperties[] = "'duration' can't be null";
        }
        if ($this->container['hash'] === null) {
            $invalidProperties[] = "'hash' can't be null";
        }
        if ($this->container['recipient_address'] === null) {
            $invalidProperties[] = "'recipient_address' can't be null";
        }
        if ($this->container['secret'] === null) {
            $invalidProperties[] = "'secret' can't be null";
        }
        if ($this->container['hash_algorithm'] === null) {
            $invalidProperties[] = "'hash_algorithm' can't be null";
        }
        if ($this->container['proof'] === null) {
            $invalidProperties[] = "'proof' can't be null";
        }
        if ($this->container['target_address'] === null) {
            $invalidProperties[] = "'target_address' can't be null";
        }
        if ($this->container['scoped_metadata_key'] === null) {
            $invalidProperties[] = "'scoped_metadata_key' can't be null";
        }
        if ($this->container['value_size_delta'] === null) {
            $invalidProperties[] = "'value_size_delta' can't be null";
        }
        if ($this->container['value_size'] === null) {
            $invalidProperties[] = "'value_size' can't be null";
        }
        if ($this->container['value'] === null) {
            $invalidProperties[] = "'value' can't be null";
        }
        if ($this->container['target_mosaic_id'] === null) {
            $invalidProperties[] = "'target_mosaic_id' can't be null";
        }
        if ($this->container['id'] === null) {
            $invalidProperties[] = "'id' can't be null";
        }
        if ($this->container['nonce'] === null) {
            $invalidProperties[] = "'nonce' can't be null";
        }
        if ($this->container['flags'] === null) {
            $invalidProperties[] = "'flags' can't be null";
        }
        if ($this->container['divisibility'] === null) {
            $invalidProperties[] = "'divisibility' can't be null";
        }
        if ($this->container['delta'] === null) {
            $invalidProperties[] = "'delta' can't be null";
        }
        if ($this->container['action'] === null) {
            $invalidProperties[] = "'action' can't be null";
        }
        if ($this->container['source_address'] === null) {
            $invalidProperties[] = "'source_address' can't be null";
        }
        if ($this->container['registration_type'] === null) {
            $invalidProperties[] = "'registration_type' can't be null";
        }
        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if ($this->container['namespace_id'] === null) {
            $invalidProperties[] = "'namespace_id' can't be null";
        }
        if ($this->container['address'] === null) {
            $invalidProperties[] = "'address' can't be null";
        }
        if ($this->container['alias_action'] === null) {
            $invalidProperties[] = "'alias_action' can't be null";
        }
        if ($this->container['min_removal_delta'] === null) {
            $invalidProperties[] = "'min_removal_delta' can't be null";
        }
        if ($this->container['min_approval_delta'] === null) {
            $invalidProperties[] = "'min_approval_delta' can't be null";
        }
        if ($this->container['address_additions'] === null) {
            $invalidProperties[] = "'address_additions' can't be null";
        }
        if ($this->container['address_deletions'] === null) {
            $invalidProperties[] = "'address_deletions' can't be null";
        }
        if ($this->container['restriction_flags'] === null) {
            $invalidProperties[] = "'restriction_flags' can't be null";
        }
        if ($this->container['restriction_additions'] === null) {
            $invalidProperties[] = "'restriction_additions' can't be null";
        }
        if ($this->container['restriction_deletions'] === null) {
            $invalidProperties[] = "'restriction_deletions' can't be null";
        }
        if ($this->container['reference_mosaic_id'] === null) {
            $invalidProperties[] = "'reference_mosaic_id' can't be null";
        }
        if ($this->container['restriction_key'] === null) {
            $invalidProperties[] = "'restriction_key' can't be null";
        }
        if ($this->container['previous_restriction_value'] === null) {
            $invalidProperties[] = "'previous_restriction_value' can't be null";
        }
        if ($this->container['new_restriction_value'] === null) {
            $invalidProperties[] = "'new_restriction_value' can't be null";
        }
        if ($this->container['previous_restriction_type'] === null) {
            $invalidProperties[] = "'previous_restriction_type' can't be null";
        }
        if ($this->container['new_restriction_type'] === null) {
            $invalidProperties[] = "'new_restriction_type' can't be null";
        }
        if ($this->container['mosaics'] === null) {
            $invalidProperties[] = "'mosaics' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets size
     *
     * @return int
     */
    public function getSize()
    {
        return $this->container['size'];
    }

    /**
     * Sets size
     *
     * @param int $size A number that allows uint 32 values.
     *
     * @return self
     */
    public function setSize($size)
    {
        if (is_null($size)) {
            throw new \InvalidArgumentException('non-nullable size cannot be null');
        }
        $this->container['size'] = $size;

        return $this;
    }

    /**
     * Gets signature
     *
     * @return string
     */
    public function getSignature()
    {
        return $this->container['signature'];
    }

    /**
     * Sets signature
     *
     * @param string $signature Entity's signature generated by the signer.
     *
     * @return self
     */
    public function setSignature($signature)
    {
        if (is_null($signature)) {
            throw new \InvalidArgumentException('non-nullable signature cannot be null');
        }
        $this->container['signature'] = $signature;

        return $this;
    }

    /**
     * Gets signer_public_key
     *
     * @return string
     */
    public function getSignerPublicKey()
    {
        return $this->container['signer_public_key'];
    }

    /**
     * Sets signer_public_key
     *
     * @param string $signer_public_key Public key.
     *
     * @return self
     */
    public function setSignerPublicKey($signer_public_key)
    {
        if (is_null($signer_public_key)) {
            throw new \InvalidArgumentException('non-nullable signer_public_key cannot be null');
        }
        $this->container['signer_public_key'] = $signer_public_key;

        return $this;
    }

    /**
     * Gets version
     *
     * @return int
     */
    public function getVersion()
    {
        return $this->container['version'];
    }

    /**
     * Sets version
     *
     * @param int $version Entity version.
     *
     * @return self
     */
    public function setVersion($version)
    {
        if (is_null($version)) {
            throw new \InvalidArgumentException('non-nullable version cannot be null');
        }
        $this->container['version'] = $version;

        return $this;
    }

    /**
     * Gets network
     *
     * @return \SymbolRestClient\Model\NetworkTypeEnum
     */
    public function getNetwork()
    {
        return $this->container['network'];
    }

    /**
     * Sets network
     *
     * @param \SymbolRestClient\Model\NetworkTypeEnum $network network
     *
     * @return self
     */
    public function setNetwork($network)
    {
        if (is_null($network)) {
            throw new \InvalidArgumentException('non-nullable network cannot be null');
        }
        $this->container['network'] = $network;

        return $this;
    }

    /**
     * Gets type
     *
     * @return int
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param int $type type
     *
     * @return self
     */
    public function setType($type)
    {
        if (is_null($type)) {
            throw new \InvalidArgumentException('non-nullable type cannot be null');
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets max_fee
     *
     * @return string
     */
    public function getMaxFee()
    {
        return $this->container['max_fee'];
    }

    /**
     * Sets max_fee
     *
     * @param string $max_fee Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     *
     * @return self
     */
    public function setMaxFee($max_fee)
    {
        if (is_null($max_fee)) {
            throw new \InvalidArgumentException('non-nullable max_fee cannot be null');
        }
        $this->container['max_fee'] = $max_fee;

        return $this;
    }

    /**
     * Gets deadline
     *
     * @return string
     */
    public function getDeadline()
    {
        return $this->container['deadline'];
    }

    /**
     * Sets deadline
     *
     * @param string $deadline Duration expressed in number of blocks.
     *
     * @return self
     */
    public function setDeadline($deadline)
    {
        if (is_null($deadline)) {
            throw new \InvalidArgumentException('non-nullable deadline cannot be null');
        }
        $this->container['deadline'] = $deadline;

        return $this;
    }

    /**
     * Gets linked_public_key
     *
     * @return string
     */
    public function getLinkedPublicKey()
    {
        return $this->container['linked_public_key'];
    }

    /**
     * Sets linked_public_key
     *
     * @param string $linked_public_key 32 bytes voting public key.
     *
     * @return self
     */
    public function setLinkedPublicKey($linked_public_key)
    {
        if (is_null($linked_public_key)) {
            throw new \InvalidArgumentException('non-nullable linked_public_key cannot be null');
        }
        $this->container['linked_public_key'] = $linked_public_key;

        return $this;
    }

    /**
     * Gets link_action
     *
     * @return \SymbolRestClient\Model\LinkActionEnum
     */
    public function getLinkAction()
    {
        return $this->container['link_action'];
    }

    /**
     * Sets link_action
     *
     * @param \SymbolRestClient\Model\LinkActionEnum $link_action link_action
     *
     * @return self
     */
    public function setLinkAction($link_action)
    {
        if (is_null($link_action)) {
            throw new \InvalidArgumentException('non-nullable link_action cannot be null');
        }
        $this->container['link_action'] = $link_action;

        return $this;
    }

    /**
     * Gets start_epoch
     *
     * @return int
     */
    public function getStartEpoch()
    {
        return $this->container['start_epoch'];
    }

    /**
     * Sets start_epoch
     *
     * @param int $start_epoch Finalization Epoch
     *
     * @return self
     */
    public function setStartEpoch($start_epoch)
    {
        if (is_null($start_epoch)) {
            throw new \InvalidArgumentException('non-nullable start_epoch cannot be null');
        }
        $this->container['start_epoch'] = $start_epoch;

        return $this;
    }

    /**
     * Gets end_epoch
     *
     * @return int
     */
    public function getEndEpoch()
    {
        return $this->container['end_epoch'];
    }

    /**
     * Sets end_epoch
     *
     * @param int $end_epoch Finalization Epoch
     *
     * @return self
     */
    public function setEndEpoch($end_epoch)
    {
        if (is_null($end_epoch)) {
            throw new \InvalidArgumentException('non-nullable end_epoch cannot be null');
        }
        $this->container['end_epoch'] = $end_epoch;

        return $this;
    }

    /**
     * Gets transactions_hash
     *
     * @return string
     */
    public function getTransactionsHash()
    {
        return $this->container['transactions_hash'];
    }

    /**
     * Sets transactions_hash
     *
     * @param string $transactions_hash transactions_hash
     *
     * @return self
     */
    public function setTransactionsHash($transactions_hash)
    {
        if (is_null($transactions_hash)) {
            throw new \InvalidArgumentException('non-nullable transactions_hash cannot be null');
        }
        $this->container['transactions_hash'] = $transactions_hash;

        return $this;
    }

    /**
     * Gets cosignatures
     *
     * @return \SymbolRestClient\Model\CosignatureDTO[]
     */
    public function getCosignatures()
    {
        return $this->container['cosignatures'];
    }

    /**
     * Sets cosignatures
     *
     * @param \SymbolRestClient\Model\CosignatureDTO[] $cosignatures Array of transaction cosignatures.
     *
     * @return self
     */
    public function setCosignatures($cosignatures)
    {
        if (is_null($cosignatures)) {
            throw new \InvalidArgumentException('non-nullable cosignatures cannot be null');
        }
        $this->container['cosignatures'] = $cosignatures;

        return $this;
    }

    /**
     * Gets transactions
     *
     * @return \SymbolRestClient\Model\EmbeddedTransactionInfoDTO[]
     */
    public function getTransactions()
    {
        return $this->container['transactions'];
    }

    /**
     * Sets transactions
     *
     * @param \SymbolRestClient\Model\EmbeddedTransactionInfoDTO[] $transactions Array of transactions initiated by different accounts.
     *
     * @return self
     */
    public function setTransactions($transactions)
    {
        if (is_null($transactions)) {
            throw new \InvalidArgumentException('non-nullable transactions cannot be null');
        }
        $this->container['transactions'] = $transactions;

        return $this;
    }

    /**
     * Gets mosaic_id
     *
     * @return string
     */
    public function getMosaicId()
    {
        return $this->container['mosaic_id'];
    }

    /**
     * Sets mosaic_id
     *
     * @param string $mosaic_id Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier.
     *
     * @return self
     */
    public function setMosaicId($mosaic_id)
    {
        if (is_null($mosaic_id)) {
            throw new \InvalidArgumentException('non-nullable mosaic_id cannot be null');
        }
        $this->container['mosaic_id'] = $mosaic_id;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return string
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param string $amount Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     *
     * @return self
     */
    public function setAmount($amount)
    {
        if (is_null($amount)) {
            throw new \InvalidArgumentException('non-nullable amount cannot be null');
        }
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets duration
     *
     * @return string
     */
    public function getDuration()
    {
        return $this->container['duration'];
    }

    /**
     * Sets duration
     *
     * @param string $duration Duration expressed in number of blocks.
     *
     * @return self
     */
    public function setDuration($duration)
    {
        if (is_null($duration)) {
            throw new \InvalidArgumentException('non-nullable duration cannot be null');
        }
        $this->container['duration'] = $duration;

        return $this;
    }

    /**
     * Gets hash
     *
     * @return string
     */
    public function getHash()
    {
        return $this->container['hash'];
    }

    /**
     * Sets hash
     *
     * @param string $hash hash
     *
     * @return self
     */
    public function setHash($hash)
    {
        if (is_null($hash)) {
            throw new \InvalidArgumentException('non-nullable hash cannot be null');
        }
        $this->container['hash'] = $hash;

        return $this;
    }

    /**
     * Gets recipient_address
     *
     * @return string
     */
    public function getRecipientAddress()
    {
        return $this->container['recipient_address'];
    }

    /**
     * Sets recipient_address
     *
     * @param string $recipient_address Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA
     *
     * @return self
     */
    public function setRecipientAddress($recipient_address)
    {
        if (is_null($recipient_address)) {
            throw new \InvalidArgumentException('non-nullable recipient_address cannot be null');
        }
        $this->container['recipient_address'] = $recipient_address;

        return $this;
    }

    /**
     * Gets secret
     *
     * @return string
     */
    public function getSecret()
    {
        return $this->container['secret'];
    }

    /**
     * Sets secret
     *
     * @param string $secret secret
     *
     * @return self
     */
    public function setSecret($secret)
    {
        if (is_null($secret)) {
            throw new \InvalidArgumentException('non-nullable secret cannot be null');
        }
        $this->container['secret'] = $secret;

        return $this;
    }

    /**
     * Gets hash_algorithm
     *
     * @return \SymbolRestClient\Model\LockHashAlgorithmEnum
     */
    public function getHashAlgorithm()
    {
        return $this->container['hash_algorithm'];
    }

    /**
     * Sets hash_algorithm
     *
     * @param \SymbolRestClient\Model\LockHashAlgorithmEnum $hash_algorithm hash_algorithm
     *
     * @return self
     */
    public function setHashAlgorithm($hash_algorithm)
    {
        if (is_null($hash_algorithm)) {
            throw new \InvalidArgumentException('non-nullable hash_algorithm cannot be null');
        }
        $this->container['hash_algorithm'] = $hash_algorithm;

        return $this;
    }

    /**
     * Gets proof
     *
     * @return string
     */
    public function getProof()
    {
        return $this->container['proof'];
    }

    /**
     * Sets proof
     *
     * @param string $proof Original random set of bytes.
     *
     * @return self
     */
    public function setProof($proof)
    {
        if (is_null($proof)) {
            throw new \InvalidArgumentException('non-nullable proof cannot be null');
        }
        $this->container['proof'] = $proof;

        return $this;
    }

    /**
     * Gets target_address
     *
     * @return string
     */
    public function getTargetAddress()
    {
        return $this->container['target_address'];
    }

    /**
     * Sets target_address
     *
     * @param string $target_address Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA
     *
     * @return self
     */
    public function setTargetAddress($target_address)
    {
        if (is_null($target_address)) {
            throw new \InvalidArgumentException('non-nullable target_address cannot be null');
        }
        $this->container['target_address'] = $target_address;

        return $this;
    }

    /**
     * Gets scoped_metadata_key
     *
     * @return string
     */
    public function getScopedMetadataKey()
    {
        return $this->container['scoped_metadata_key'];
    }

    /**
     * Sets scoped_metadata_key
     *
     * @param string $scoped_metadata_key Metadata key scoped to source, target and type expressed.
     *
     * @return self
     */
    public function setScopedMetadataKey($scoped_metadata_key)
    {
        if (is_null($scoped_metadata_key)) {
            throw new \InvalidArgumentException('non-nullable scoped_metadata_key cannot be null');
        }
        $this->container['scoped_metadata_key'] = $scoped_metadata_key;

        return $this;
    }

    /**
     * Gets value_size_delta
     *
     * @return int
     */
    public function getValueSizeDelta()
    {
        return $this->container['value_size_delta'];
    }

    /**
     * Sets value_size_delta
     *
     * @param int $value_size_delta Change in value size in bytes.
     *
     * @return self
     */
    public function setValueSizeDelta($value_size_delta)
    {
        if (is_null($value_size_delta)) {
            throw new \InvalidArgumentException('non-nullable value_size_delta cannot be null');
        }
        $this->container['value_size_delta'] = $value_size_delta;

        return $this;
    }

    /**
     * Gets value_size
     *
     * @return int
     */
    public function getValueSize()
    {
        return $this->container['value_size'];
    }

    /**
     * Sets value_size
     *
     * @param int $value_size A number that allows uint 32 values.
     *
     * @return self
     */
    public function setValueSize($value_size)
    {
        if (is_null($value_size)) {
            throw new \InvalidArgumentException('non-nullable value_size cannot be null');
        }
        $this->container['value_size'] = $value_size;

        return $this;
    }

    /**
     * Gets value
     *
     * @return string
     */
    public function getValue()
    {
        return $this->container['value'];
    }

    /**
     * Sets value
     *
     * @param string $value Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     *
     * @return self
     */
    public function setValue($value)
    {
        if (is_null($value)) {
            throw new \InvalidArgumentException('non-nullable value cannot be null');
        }
        $this->container['value'] = $value;

        return $this;
    }

    /**
     * Gets target_mosaic_id
     *
     * @return string
     */
    public function getTargetMosaicId()
    {
        return $this->container['target_mosaic_id'];
    }

    /**
     * Sets target_mosaic_id
     *
     * @param string $target_mosaic_id Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier.
     *
     * @return self
     */
    public function setTargetMosaicId($target_mosaic_id)
    {
        if (is_null($target_mosaic_id)) {
            throw new \InvalidArgumentException('non-nullable target_mosaic_id cannot be null');
        }
        $this->container['target_mosaic_id'] = $target_mosaic_id;

        return $this;
    }

    /**
     * Gets target_namespace_id
     *
     * @return string|null
     */
    public function getTargetNamespaceId()
    {
        return $this->container['target_namespace_id'];
    }

    /**
     * Sets target_namespace_id
     *
     * @param string|null $target_namespace_id Namespace identifier.
     *
     * @return self
     */
    public function setTargetNamespaceId($target_namespace_id)
    {
        if (is_null($target_namespace_id)) {
            throw new \InvalidArgumentException('non-nullable target_namespace_id cannot be null');
        }
        $this->container['target_namespace_id'] = $target_namespace_id;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id Namespace identifier.
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets nonce
     *
     * @return int
     */
    public function getNonce()
    {
        return $this->container['nonce'];
    }

    /**
     * Sets nonce
     *
     * @param int $nonce A number that allows uint 32 values.
     *
     * @return self
     */
    public function setNonce($nonce)
    {
        if (is_null($nonce)) {
            throw new \InvalidArgumentException('non-nullable nonce cannot be null');
        }
        $this->container['nonce'] = $nonce;

        return $this;
    }

    /**
     * Gets flags
     *
     * @return int
     */
    public function getFlags()
    {
        return $this->container['flags'];
    }

    /**
     * Sets flags
     *
     * @param int $flags - 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user.
     *
     * @return self
     */
    public function setFlags($flags)
    {
        if (is_null($flags)) {
            throw new \InvalidArgumentException('non-nullable flags cannot be null');
        }
        $this->container['flags'] = $flags;

        return $this;
    }

    /**
     * Gets divisibility
     *
     * @return int
     */
    public function getDivisibility()
    {
        return $this->container['divisibility'];
    }

    /**
     * Sets divisibility
     *
     * @param int $divisibility Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6.
     *
     * @return self
     */
    public function setDivisibility($divisibility)
    {
        if (is_null($divisibility)) {
            throw new \InvalidArgumentException('non-nullable divisibility cannot be null');
        }
        $this->container['divisibility'] = $divisibility;

        return $this;
    }

    /**
     * Gets delta
     *
     * @return string
     */
    public function getDelta()
    {
        return $this->container['delta'];
    }

    /**
     * Sets delta
     *
     * @param string $delta Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     *
     * @return self
     */
    public function setDelta($delta)
    {
        if (is_null($delta)) {
            throw new \InvalidArgumentException('non-nullable delta cannot be null');
        }
        $this->container['delta'] = $delta;

        return $this;
    }

    /**
     * Gets action
     *
     * @return \SymbolRestClient\Model\MosaicSupplyChangeActionEnum
     */
    public function getAction()
    {
        return $this->container['action'];
    }

    /**
     * Sets action
     *
     * @param \SymbolRestClient\Model\MosaicSupplyChangeActionEnum $action action
     *
     * @return self
     */
    public function setAction($action)
    {
        if (is_null($action)) {
            throw new \InvalidArgumentException('non-nullable action cannot be null');
        }
        $this->container['action'] = $action;

        return $this;
    }

    /**
     * Gets source_address
     *
     * @return string
     */
    public function getSourceAddress()
    {
        return $this->container['source_address'];
    }

    /**
     * Sets source_address
     *
     * @param string $source_address Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA
     *
     * @return self
     */
    public function setSourceAddress($source_address)
    {
        if (is_null($source_address)) {
            throw new \InvalidArgumentException('non-nullable source_address cannot be null');
        }
        $this->container['source_address'] = $source_address;

        return $this;
    }

    /**
     * Gets parent_id
     *
     * @return string|null
     */
    public function getParentId()
    {
        return $this->container['parent_id'];
    }

    /**
     * Sets parent_id
     *
     * @param string|null $parent_id Namespace identifier.
     *
     * @return self
     */
    public function setParentId($parent_id)
    {
        if (is_null($parent_id)) {
            throw new \InvalidArgumentException('non-nullable parent_id cannot be null');
        }
        $this->container['parent_id'] = $parent_id;

        return $this;
    }

    /**
     * Gets registration_type
     *
     * @return \SymbolRestClient\Model\NamespaceRegistrationTypeEnum
     */
    public function getRegistrationType()
    {
        return $this->container['registration_type'];
    }

    /**
     * Sets registration_type
     *
     * @param \SymbolRestClient\Model\NamespaceRegistrationTypeEnum $registration_type registration_type
     *
     * @return self
     */
    public function setRegistrationType($registration_type)
    {
        if (is_null($registration_type)) {
            throw new \InvalidArgumentException('non-nullable registration_type cannot be null');
        }
        $this->container['registration_type'] = $registration_type;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name Namespace name.
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets namespace_id
     *
     * @return string
     */
    public function getNamespaceId()
    {
        return $this->container['namespace_id'];
    }

    /**
     * Sets namespace_id
     *
     * @param string $namespace_id Namespace identifier.
     *
     * @return self
     */
    public function setNamespaceId($namespace_id)
    {
        if (is_null($namespace_id)) {
            throw new \InvalidArgumentException('non-nullable namespace_id cannot be null');
        }
        $this->container['namespace_id'] = $namespace_id;

        return $this;
    }

    /**
     * Gets address
     *
     * @return string
     */
    public function getAddress()
    {
        return $this->container['address'];
    }

    /**
     * Sets address
     *
     * @param string $address Address encoded using a 32-character set.
     *
     * @return self
     */
    public function setAddress($address)
    {
        if (is_null($address)) {
            throw new \InvalidArgumentException('non-nullable address cannot be null');
        }
        $this->container['address'] = $address;

        return $this;
    }

    /**
     * Gets alias_action
     *
     * @return \SymbolRestClient\Model\AliasActionEnum
     */
    public function getAliasAction()
    {
        return $this->container['alias_action'];
    }

    /**
     * Sets alias_action
     *
     * @param \SymbolRestClient\Model\AliasActionEnum $alias_action alias_action
     *
     * @return self
     */
    public function setAliasAction($alias_action)
    {
        if (is_null($alias_action)) {
            throw new \InvalidArgumentException('non-nullable alias_action cannot be null');
        }
        $this->container['alias_action'] = $alias_action;

        return $this;
    }

    /**
     * Gets min_removal_delta
     *
     * @return int
     */
    public function getMinRemovalDelta()
    {
        return $this->container['min_removal_delta'];
    }

    /**
     * Sets min_removal_delta
     *
     * @param int $min_removal_delta Number of signatures needed to remove a cosignatory. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories.
     *
     * @return self
     */
    public function setMinRemovalDelta($min_removal_delta)
    {
        if (is_null($min_removal_delta)) {
            throw new \InvalidArgumentException('non-nullable min_removal_delta cannot be null');
        }
        $this->container['min_removal_delta'] = $min_removal_delta;

        return $this;
    }

    /**
     * Gets min_approval_delta
     *
     * @return int
     */
    public function getMinApprovalDelta()
    {
        return $this->container['min_approval_delta'];
    }

    /**
     * Sets min_approval_delta
     *
     * @param int $min_approval_delta Number of signatures needed to approve a transaction. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories.
     *
     * @return self
     */
    public function setMinApprovalDelta($min_approval_delta)
    {
        if (is_null($min_approval_delta)) {
            throw new \InvalidArgumentException('non-nullable min_approval_delta cannot be null');
        }
        $this->container['min_approval_delta'] = $min_approval_delta;

        return $this;
    }

    /**
     * Gets address_additions
     *
     * @return string[]
     */
    public function getAddressAdditions()
    {
        return $this->container['address_additions'];
    }

    /**
     * Sets address_additions
     *
     * @param string[] $address_additions Array of cosignatory accounts to add.
     *
     * @return self
     */
    public function setAddressAdditions($address_additions)
    {
        if (is_null($address_additions)) {
            throw new \InvalidArgumentException('non-nullable address_additions cannot be null');
        }
        $this->container['address_additions'] = $address_additions;

        return $this;
    }

    /**
     * Gets address_deletions
     *
     * @return string[]
     */
    public function getAddressDeletions()
    {
        return $this->container['address_deletions'];
    }

    /**
     * Sets address_deletions
     *
     * @param string[] $address_deletions Array of cosignatory accounts to delete.
     *
     * @return self
     */
    public function setAddressDeletions($address_deletions)
    {
        if (is_null($address_deletions)) {
            throw new \InvalidArgumentException('non-nullable address_deletions cannot be null');
        }
        $this->container['address_deletions'] = $address_deletions;

        return $this;
    }

    /**
     * Gets restriction_flags
     *
     * @return \SymbolRestClient\Model\AccountRestrictionFlagsEnum
     */
    public function getRestrictionFlags()
    {
        return $this->container['restriction_flags'];
    }

    /**
     * Sets restriction_flags
     *
     * @param \SymbolRestClient\Model\AccountRestrictionFlagsEnum $restriction_flags restriction_flags
     *
     * @return self
     */
    public function setRestrictionFlags($restriction_flags)
    {
        if (is_null($restriction_flags)) {
            throw new \InvalidArgumentException('non-nullable restriction_flags cannot be null');
        }
        $this->container['restriction_flags'] = $restriction_flags;

        return $this;
    }

    /**
     * Gets restriction_additions
     *
     * @return \SymbolRestClient\Model\TransactionTypeEnum[]
     */
    public function getRestrictionAdditions()
    {
        return $this->container['restriction_additions'];
    }

    /**
     * Sets restriction_additions
     *
     * @param \SymbolRestClient\Model\TransactionTypeEnum[] $restriction_additions Account restriction additions.
     *
     * @return self
     */
    public function setRestrictionAdditions($restriction_additions)
    {
        if (is_null($restriction_additions)) {
            throw new \InvalidArgumentException('non-nullable restriction_additions cannot be null');
        }
        $this->container['restriction_additions'] = $restriction_additions;

        return $this;
    }

    /**
     * Gets restriction_deletions
     *
     * @return \SymbolRestClient\Model\TransactionTypeEnum[]
     */
    public function getRestrictionDeletions()
    {
        return $this->container['restriction_deletions'];
    }

    /**
     * Sets restriction_deletions
     *
     * @param \SymbolRestClient\Model\TransactionTypeEnum[] $restriction_deletions Account restriction deletions.
     *
     * @return self
     */
    public function setRestrictionDeletions($restriction_deletions)
    {
        if (is_null($restriction_deletions)) {
            throw new \InvalidArgumentException('non-nullable restriction_deletions cannot be null');
        }
        $this->container['restriction_deletions'] = $restriction_deletions;

        return $this;
    }

    /**
     * Gets reference_mosaic_id
     *
     * @return string
     */
    public function getReferenceMosaicId()
    {
        return $this->container['reference_mosaic_id'];
    }

    /**
     * Sets reference_mosaic_id
     *
     * @param string $reference_mosaic_id Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier.
     *
     * @return self
     */
    public function setReferenceMosaicId($reference_mosaic_id)
    {
        if (is_null($reference_mosaic_id)) {
            throw new \InvalidArgumentException('non-nullable reference_mosaic_id cannot be null');
        }
        $this->container['reference_mosaic_id'] = $reference_mosaic_id;

        return $this;
    }

    /**
     * Gets restriction_key
     *
     * @return string
     */
    public function getRestrictionKey()
    {
        return $this->container['restriction_key'];
    }

    /**
     * Sets restriction_key
     *
     * @param string $restriction_key Restriction key.
     *
     * @return self
     */
    public function setRestrictionKey($restriction_key)
    {
        if (is_null($restriction_key)) {
            throw new \InvalidArgumentException('non-nullable restriction_key cannot be null');
        }
        $this->container['restriction_key'] = $restriction_key;

        return $this;
    }

    /**
     * Gets previous_restriction_value
     *
     * @return string
     */
    public function getPreviousRestrictionValue()
    {
        return $this->container['previous_restriction_value'];
    }

    /**
     * Sets previous_restriction_value
     *
     * @param string $previous_restriction_value Restriction value.
     *
     * @return self
     */
    public function setPreviousRestrictionValue($previous_restriction_value)
    {
        if (is_null($previous_restriction_value)) {
            throw new \InvalidArgumentException('non-nullable previous_restriction_value cannot be null');
        }
        $this->container['previous_restriction_value'] = $previous_restriction_value;

        return $this;
    }

    /**
     * Gets new_restriction_value
     *
     * @return string
     */
    public function getNewRestrictionValue()
    {
        return $this->container['new_restriction_value'];
    }

    /**
     * Sets new_restriction_value
     *
     * @param string $new_restriction_value Restriction value.
     *
     * @return self
     */
    public function setNewRestrictionValue($new_restriction_value)
    {
        if (is_null($new_restriction_value)) {
            throw new \InvalidArgumentException('non-nullable new_restriction_value cannot be null');
        }
        $this->container['new_restriction_value'] = $new_restriction_value;

        return $this;
    }

    /**
     * Gets previous_restriction_type
     *
     * @return \SymbolRestClient\Model\MosaicRestrictionTypeEnum
     */
    public function getPreviousRestrictionType()
    {
        return $this->container['previous_restriction_type'];
    }

    /**
     * Sets previous_restriction_type
     *
     * @param \SymbolRestClient\Model\MosaicRestrictionTypeEnum $previous_restriction_type previous_restriction_type
     *
     * @return self
     */
    public function setPreviousRestrictionType($previous_restriction_type)
    {
        if (is_null($previous_restriction_type)) {
            throw new \InvalidArgumentException('non-nullable previous_restriction_type cannot be null');
        }
        $this->container['previous_restriction_type'] = $previous_restriction_type;

        return $this;
    }

    /**
     * Gets new_restriction_type
     *
     * @return \SymbolRestClient\Model\MosaicRestrictionTypeEnum
     */
    public function getNewRestrictionType()
    {
        return $this->container['new_restriction_type'];
    }

    /**
     * Sets new_restriction_type
     *
     * @param \SymbolRestClient\Model\MosaicRestrictionTypeEnum $new_restriction_type new_restriction_type
     *
     * @return self
     */
    public function setNewRestrictionType($new_restriction_type)
    {
        if (is_null($new_restriction_type)) {
            throw new \InvalidArgumentException('non-nullable new_restriction_type cannot be null');
        }
        $this->container['new_restriction_type'] = $new_restriction_type;

        return $this;
    }

    /**
     * Gets mosaics
     *
     * @return \SymbolRestClient\Model\UnresolvedMosaic[]
     */
    public function getMosaics()
    {
        return $this->container['mosaics'];
    }

    /**
     * Sets mosaics
     *
     * @param \SymbolRestClient\Model\UnresolvedMosaic[] $mosaics Array of mosaics sent to the recipient.
     *
     * @return self
     */
    public function setMosaics($mosaics)
    {
        if (is_null($mosaics)) {
            throw new \InvalidArgumentException('non-nullable mosaics cannot be null');
        }
        $this->container['mosaics'] = $mosaics;

        return $this;
    }

    /**
     * Gets message
     *
     * @return string|null
     */
    public function getMessage()
    {
        return $this->container['message'];
    }

    /**
     * Sets message
     *
     * @param string|null $message Transfer transaction message
     *
     * @return self
     */
    public function setMessage($message)
    {
        if (is_null($message)) {
            throw new \InvalidArgumentException('non-nullable message cannot be null');
        }
        $this->container['message'] = $message;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


